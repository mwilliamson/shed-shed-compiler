module shed.compiler.nodes;

// TODO: to just expose the class as a function, need to wrap in an
// identity function that's typed as Function[...] -> Function[...]

members {
    Node,
    
    formalArgument FormalArgumentNode,
    FormalArgumentNode,
    memberDeclaration MemberDeclarationNode,
    MemberDeclarationNode,
    
    unit UnitNode,
    UnitNode,
    number NumberNode,
    NumberNode,
    bool BooleanNode,
    BooleanNode,
    string StringNode,
    StringNode,
    variableReference VariableReferenceNode,
    VariableReferenceNode,
    ref VariableReferenceNode,
    ifThenElse IfThenElseNode,
    IfThenElseNode,
    call CallNode,
    CallNode,
    typeApplication TypeApplicationNode,
    TypeApplicationNode,
    memberAccess MemberAccessNode,
    MemberAccessNode,
    func FunctionNode,
    FunctionNode,
    classDeclaration ClassNode,
    ClassNode,
    obj ObjectNode,
    ObjectNode,
    doBlock DoBlockNode,
    DoBlockNode,
    
    expressionStatement ExpressionStatementNode,
    ExpressionStatementNode,
    ret ReturnStatementNode,
    returnStatement ReturnStatementNode,
    ReturnStatementNode,
    valDeclaration ValDeclarationNode,
    ValDeclarationNode,
    definition DefinitionNode,
    DefinitionNode,
    
    importStatement ImportNode,
    ImportNode,
    moduleNode ModuleNode,
    ModuleNode
}

import structs;

// TODO: should be an interface
def Node class() => {
}

def FormalArgumentNode class(name: String, type: ExpressionNode) => {
    members {
        name fun() => name,
        type fun() => type,
        struct fun() => structs.create(FormalArgumentNode, listOf(name, type))
    }
}

def MemberDeclarationNode class(name: String, value: ExpressionNode) => {
    members {
        name fun() => name,
        value fun() => value,
        struct fun() => structs.create(MemberDeclarationNode, listOf(name, value))
    }
}

def UnitNode class() => {
    members {
        struct fun() => structs.create(UnitNode, emptyList)
    }
}

def NumberNode class(value: Double) => {
    members {
        value fun() => value,
        struct fun() => structs.create(NumberNode, listOf(value))
    }
}

def BooleanNode class(value: Boolean) => {
    members {
        value fun() => value,
        struct fun() => structs.create(BooleanNode, listOf(value))
    }
}

def StringNode class(value: String) => {
    members {
        value fun() => value,
        struct fun() => structs.create(StringNode, listOf(value))
    }
}

def VariableReferenceNode class(identifier: String) => {
    members {
        identifier fun() => identifier,
        struct fun() => structs.create(VariableReferenceNode, listOf(identifier))
    }
}

def IfThenElseNode class(condition: ExpressionNode, trueValue: ExpressionNode, falseValue: ExpressionNode) => {
    members {
        condition fun() => condition,
        trueValue fun() => trueValue,
        falseValue fun() => falseValue,
        struct fun() => structs.create(IfThenElseNode, listOf(condition, trueValue, falseValue))
    }
}

def CallNode class(callee: ExpressionNode, args: List[ExpressionNode]) => {
    members {
        callee fun() => callee,
        args fun() => args,
        struct fun() => structs.create(CallNode, listOf(callee, args))
    }
}

def TypeApplicationNode class(callee: ExpressionNode, args: List[ExpressionNode]) => {
    members {
        callee fun() => callee,
        args fun() => args,
        struct fun() => structs.create(TypeApplicationNode, listOf(callee, args))
    }
}

def MemberAccessNode class(left: ExpressionNode, memberName: String) => {
    members {
        left fun() => left,
        memberName fun() => memberName,
        struct fun() => structs.create(MemberAccessNode, listOf(left, memberName))
    }
}

def FunctionNode class(formalArgs: List[FormalArgumentNode], body: ExpressionNode) => {
    members {
        formalArgs fun() => formalArgs,
        body fun() => body,
        struct fun() => structs.create(FunctionNode, listOf(formalArgs, body))
    }
}

def ClassNode class(formalArgs: List[FormalArgumentNode], body: ObjectNode) => {
    members {
        formalArgs fun() => formalArgs,
        body fun() => body,
        struct fun() => structs.create(ClassNode, listOf(formalArgs, body))
    }
}

def ObjectNode class(memberDeclarations: List[MemberNode], statements: List[StatementNode]) => {
    members {
        memberDeclarations fun() => memberDeclarations,
        statements fun() => statements,
        struct fun() => structs.create(ObjectNode, listOf(memberDeclarations, statements))
    }
}

def DoBlockNode class(statements: List[StatementNode]) => {
    members {
        statements fun() => statements,
        struct fun() => structs.create(DoBlockNode, listOf(statements))
    }
}

def ExpressionStatementNode class(expression: ExpressionNode) => {
    members {
        expression fun() => expression,
        struct fun() => structs.create(ExpressionStatementNode, listOf(expression))
    }
}

def ReturnStatementNode class(value: ExpressionNode) => {
    members {
        value fun() => value,
        struct fun() => structs.create(ReturnStatementNode, listOf(value))  
    }
}

def ValDeclarationNode class(name: String, value: ExpressionNode) => {
    members {
        name fun() => name,
        value fun() => value,
        struct fun() => structs.create(ValDeclarationNode, listOf(name, value))  
    }
}

def DefinitionNode class(name: String, value: ExpressionNode) => {
    members {
        name fun() => name,
        value fun() => value,
        struct fun() => structs.create(DefinitionNode, listOf(name, value))  
    }
}

def ImportNode class(moduleName: List[String]) => {
    members {
        moduleName fun() => moduleName,
        struct fun() => structs.create(ImportNode, listOf(moduleName))
    }
}

def ModuleNode class(name: List[String], memberDeclarations: List[MemberNode], statements: List[StatementNode]) => {
    members {
        name fun() => name,
        memberDeclarations fun() => memberDeclarations,
        statements fun() => statements,
        struct fun() => structs.create(ModuleNode, listOf(name, memberDeclarations, statements))
    }
}
