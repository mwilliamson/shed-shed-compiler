module shed.compiler.nodes;

members {
    Node,
    
    formalArgument FormalArgumentNode,
    FormalArgumentNode,
    
    unit UnitNode,
    UnitNode,
    number NumberNode,
    NumberNode,
    boolean BooleanNode,
    BooleanNode,
    string StringNode,
    StringNode,
    variableReference VariableReferenceNode,
    VariableReferenceNode,
    ref VariableReferenceNode,
    ifThenElse IfThenElseNode,
    IfThenElseNode,
    call CallNode,
    CallNode,
    memberAccess MemberAccessNode,
    MemberAccessNode,
    function FunctionNode,
    FunctionNode,
    
    expressionStatement ExpressionStatementNode,
    ExpressionStatementNode,
    returnStatement ReturnStatementNode,
    ReturnStatementNode,
    
    moduleNode ModuleNode,
    ModuleNode
}

import structs;

// TODO: should be an interface
def Node class() => {
}

def FormalArgumentNode class(name: String, type: ExpressionNode) => {
    members {
        name fun() => name,
        type fun() => type,
        struct fun() => structs.create(FormalArgumentNode, listOf(name, type))
    }
}

def UnitNode class() => {
    members {
        struct fun() => structs.create(UnitNode, emptyList)
    }
}

def NumberNode class(value: Double) => {
    members {
        value fun() => value,
        struct fun() => structs.create(NumberNode, listOf(value))
    }
}

def BooleanNode class(value: Boolean) => {
    members {
        value fun() => value,
        struct fun() => structs.create(BooleanNode, listOf(value))
    }
}

def StringNode class(value: String) => {
    members {
        value fun() => value,
        struct fun() => structs.create(StringNode, listOf(value))
    }
}

def VariableReferenceNode class(identifier: String) => {
    members {
        identifier fun() => identifier,
        struct fun() => structs.create(VariableReferenceNode, listOf(identifier))
    }
}

def IfThenElseNode class(condition: ExpressionNode, trueValue: ExpressionNode, falseValue: ExpressionNode) => {
    members {
        condition fun() => condition,
        trueValue fun() => trueValue,
        falseValue fun() => falseValue,
        struct fun() => structs.create(IfThenElseNode, listOf(condition, trueValue, falseValue))
    }
}

def CallNode class(callee: ExpressionNode, args: List[ExpressionNode]) => {
    members {
        callee fun() => callee,
        args fun() => args,
        struct fun() => structs.create(CallNode, listOf(callee, args))
    }
}

def MemberAccessNode class(left: ExpressionNode, memberName: String) => {
    members {
        left fun() => left,
        memberName fun() => memberName,
        struct fun() => structs.create(MemberAccessNode, listOf(left, memberName))
    }
}

def FunctionNode class(formalArgs: List[FormalArgumentNode], body: ExpressionNode) => {
    members {
        formalArgs fun() => formalArgs,
        body fun() => body,
        struct fun() => structs.create(FunctionNode, listOf(formalArgs, body))
    }
}

def ExpressionStatementNode class(expression: ExpressionNode) => {
    members {
        expression fun() => expression,
        struct fun() => structs.create(ExpressionStatementNode, listOf(expression))
    }
}

def ReturnStatementNode class(value: ExpressionNode) => {
    members {
        value fun() => value,
        struct fun() => structs.create(ReturnStatementNode, listOf(value))  
    }
}

def ModuleNode class(statements: List[StatementNode]) => {
    members {
        statements fun() => statements,
        struct fun() => structs.create(ModuleNode, listOf(statements))
    }
}
