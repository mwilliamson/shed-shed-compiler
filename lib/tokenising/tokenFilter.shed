module shed/compiler/tokenising/tokenFilter;

members {
    filterTokens
}

import sequences;
import lazySequences;
import lists;
import regex;

import shed/compiler/tokenising/tokens;
import shed/compiler/results

def filterTokens fun(input: Sequence[Token]) =>
    results.success(lists.reversed(filterTokens2(sequences.nil, input, sequences.nil)))

def filterTokens2 fun(accumulator: Sequence[Sequence[Token]], input: Sequence[Token], indentationStack: Sequence[Integer]) =>
    if sequences.isEmpty(input) then
        lazySequences.concat(accumulator)
    else
        extractNewline(input.currentItem(), indentationStack)
            .map(fun(filtered: Sequence[Token], rest: Sequence[Token], newIndentationStack: Sequence[Integer]) =>
                filterTokens2(sequences.cons(filtered, accumulator), rest, newIndentationStack)
            )

def extractNewline fun(input: SequenceItem[Token], indentationStack: Sequence[Integer]) => let
    val token = input.head()
    val withTail = fun(filtered: Sequence[Token]) =>
        tuple(filtered, input.tail(), indentationStack)
        
    in if isSymbol(token, "{") then
        let val noSignificantWhitespace = fun() =>
            tuple(
                sequences.singleton(token),
                input.tail(),
                sequences.cons(currentIndentation(indentationStack), indentationStack)
            )
            
        in sequences.head(input.tail()).map(fun(nextToken: Token) =>
            if nextToken.name().equals("whitespace") then
                regex.create("\n( *)$").exec(nextToken.value())
                    .map(fun(regexResult: RegexResult) =>
                        tuple(
                            sequences.singleton(token),
                            input.tail(),
                            sequences.cons(regexResult.capture(1).length(), indentationStack)
                        )
                    )
                    .valueOrElse(noSignificantWhitespace)
            else
                noSignificantWhitespace()
        ).valueOrElse(noSignificantWhitespace)
        
    else if isSymbol(token, "}") then
        tuple(
            sequences.singleton(token),
            input.tail(),
            if sequences.isEmpty(indentationStack) then
                sequences.nil
            else
                indentationStack.tail()
        )
        
    else if token.name().equals("whitespace") then let
        val isAtCorrectIndentation = isNewlineAtIndentation(
            token.value(),
            currentIndentation(indentationStack)
        )
        val isSignificantNewline = or(
            not(nextTokenIsComment(input.tail())) && isAtCorrectIndentation,
            nextTokenIsClosingBrace(input.tail()) && regex.create("\n").test(token.value())
        )
        in if isSignificantNewline then
            withTail(sequences.singleton(tokens.newline(token.source())))
        else
            withTail(sequences.nil)
            
    else if token.name().equals("comment") then
        withTail(sequences.nil)
        
    else
        withTail(sequences.singleton(token))

def nextTokenIsComment fun(input: Sequence[Token]) =>
    nextTokenIs(
        fun(token: Token) => token.name().equals("comment"),
        input
    )

def nextTokenIsClosingBrace fun(input: Sequence[Token]) =>
    nextTokenIs(
        fun(token: Token) => isSymbol(token, "}"),
        input
    )

def nextTokenIs fun(predicate: Function[Token, Boolean], input: Sequence[Token]) =>
    sequences.head(input)
        .map(predicate)
        .valueOrElse(fun() => false)

def isNewlineAtIndentation fun(value: String, indentation: Integer) =>
    regex.create("\n( *)$")
        .exec(value)
        .map(fun(result: RegexResult) =>
            result.capture(1).length().equals(indentation)
        )
        .valueOrElse(fun() => false)

def isSymbol fun(token: Token, value: String) =>
    isTokenValue(token, "symbol", value)

def isTokenValue fun(token: Token, type: String, value: String) =>
    token.name().equals(type) && token.value().equals(value)

def currentIndentation fun(indentationStack: Sequence[Integer]) =>
    sequences.head(indentationStack).valueOrElse(fun() => 0)
