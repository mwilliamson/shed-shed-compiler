module shed.compiler.parsing.statements;

members {
    statementRule
}

import lop.rules;
import lop.results;
import lop.error.Error;

import shed.compiler.nodes;
import shed.compiler.parsing.tokenRules;

def statementRule fun(expressionRule: Rule[ExpressionNode]) => do {
    val statementTerminator = tokenRules.symbol(";");
    
    val expressionStatementRule =
        rules.sequence()
            .capture(expressionRule)
            .next(statementTerminator)
            .map(nodes.expressionStatement);
    
    val returnRule =
        rules.sequence()
            .next(tokenRules.keyword("return"))
            .cut()
            .capture(expressionRule)
            .next(statementTerminator)
            .map(nodes.returnStatement);
    
    val valRule =
        rules.sequence()
            .next(tokenRules.keyword("val"))
            .cut()
            .capture(tokenRules.identifier())
            .next(tokenRules.symbol("="))
            .capture(expressionRule)
            .next(statementTerminator)
            .map(nodes.valDeclaration);
    
    val defRule =
        rules.sequence()
            .next(tokenRules.keyword("def"))
            .cut()
            .capture(tokenRules.identifier())
            .capture(expressionRule)
            .next(rules.optional(tokenRules.symbol(";")))
            .map(nodes.definition);
    
    return rules.firstOf("statement",
        listOf(
            returnRule,
            valRule,
            defRule,
            expressionStatementRule
        )
    );
}

