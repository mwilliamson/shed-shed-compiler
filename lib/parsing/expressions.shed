package shed.compiler.parsing;

import tuples;

import shed.compiler.nodes;
import shed.compiler.nodes.NumberNode;
import shed.compiler.nodes.UnitNode;
import shed.compiler.nodes.BooleanNode;
import lop.rules;

public val expressions = object {
    def symbolRule fun(value: String) =>
        rules.token("symbol", value);
        
    val numberRule = rules.map[String, NumberNode](
        rules.tokenOfType("number"),
        nodes.number
    );
    
    val unitRule = rules.map[Unit, UnitNode](
        rules.sequence()
            .next(symbolRule("("))
            .next(symbolRule(")"))
            .end(),
        fun(_: Any) => nodes.unit()
    );
    
    val trueRule = rules.map[Unit, BooleanNode](
        rules.token("keyword", "true"),
        fun() => nodes.boolean(true)
    );
    
    val falseRule = rules.map[Unit, BooleanNode](
        rules.token("keyword", "false"),
        fun() => nodes.boolean(false)
    );
    
    val booleanRule = rules.firstOf("Boolean", listOf(trueRule, falseRule));
            
    val stringRule = rules.map(
        rules.tokenOfType("string"),
        nodes.string
    );
    
    val variableReferenceRule = rules.map(
        rules.tokenOfType("identifier"),
        nodes.variableReference
    );
    
    def bracketedRule fun(tokens: Sequence[Token]) =>
        rules.map(
            rules.sequence()
                .next(symbolRule("("))
                .capture(expressionRule)
                .next(symbolRule(")"))
                .end(),
            tuples.head
        )(tokens)
        
    def callRule fun(tokens: Sequence[Token]) =>
        rules.map(
            rules.sequence()
                .capture(primaryExpressionRule)
                .next(symbolRule("("))
                .next(symbolRule(")"))
                .end(),
            fun(values: Tuple[ExpressionNode]) => nodes.call(tuples.head(values), emptyList)
        )(tokens)
    
    val primaryExpressionRule = rules.firstOf("primary expression",
        listOf(
            unitRule,
            numberRule,
            booleanRule,
            stringRule,
            variableReferenceRule,
            bracketedRule
        )
    );
    
    public val expressionRule = rules.firstOf("expression",
        listOf(
            callRule,
            primaryExpressionRule
        )
    );
};
