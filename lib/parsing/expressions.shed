module shed.compiler.parsing.expressions;

members {
    expressionRule
}

import shed.compiler.nodes;
import shed.compiler.nodes.NumberNode;
import shed.compiler.nodes.UnitNode;
import shed.compiler.nodes.BooleanNode;
import lop.rules;
import lop.pratt;

def symbolRule fun(value: String) =>
    rules.token("symbol", value);
    
def keywordRule fun(value: String) =>
    rules.token("keyword", value);
    
val numberRule = rules.map[String, NumberNode](
    rules.tokenOfType("number"),
    nodes.number
);

val unitRule =
    rules.sequence()
        .next(symbolRule("("))
        .next(symbolRule(")"))
        .map(fun() => nodes.unit());

val trueRule = rules.map[Unit, BooleanNode](
    rules.token("keyword", "true"),
    fun() => nodes.boolean(true)
);

val falseRule = rules.map[Unit, BooleanNode](
    rules.token("keyword", "false"),
    fun() => nodes.boolean(false)
);

val booleanRule = rules.firstOf("Boolean", listOf(trueRule, falseRule));
        
val stringRule = rules.map(
    rules.tokenOfType("string"),
    nodes.string
);

val variableReferenceRule = rules.map(
    rules.tokenOfType("identifier"),
    nodes.variableReference
);

def ifThenElseRule fun(tokens: Sequence[Token]) =>
    rules.sequence()
        .next(keywordRule("if"))
        .cut()
        .capture(expressionRule)
        .next(keywordRule("then"))
        .capture(expressionRule)
        .next(keywordRule("else"))
        .capture(expressionRule)
        .map(nodes.ifThenElse)
        (tokens)

def bracketedRule fun(tokens: Sequence[Token]) =>
    rules.sequence()
        .next(symbolRule("("))
        .capture(expressionRule)
        .cut()
        .next(symbolRule(")"))
        .head()
        (tokens)
    
def partialCallRule fun(tokens: Sequence[Token]) =>
    rules.sequence()
        .next(symbolRule("("))
        .cut()
        .capture(rules.zeroOrMoreWithSeparator(expressionRule, symbolRule(",")))
        .next(symbolRule(")"))
        .map(fun(args: List[ExpressionNode]) =>
            fun(left: ExpressionNode) => nodes.call(left, args))
        (tokens)
    
def partialMemberAccessRule fun(tokens: Sequence[Token]) =>
    rules.sequence()
        .next(symbolRule("."))
        .cut()
        .capture(rules.tokenOfType("identifier"))
        .map(fun(memberName: String) =>
            fun(left: ExpressionNode) => nodes.memberAccess(left, memberName))
        (tokens)

val primaryExpressionRule = rules.firstOf("primary expression",
    listOf(
        unitRule,
        numberRule,
        booleanRule,
        stringRule,
        variableReferenceRule,
        ifThenElseRule,
        bracketedRule
    )
);

val expressionParser = pratt.parser("expression",
    listOf(primaryExpressionRule),
    listOf(
        pratt.infix("call", partialCallRule),
        pratt.infix("memberAccess", partialMemberAccessRule)
    )
);

val expressionRule = expressionParser.rule();
