package shed.compiler.parsing;

import lazySequenceables;
import sequenceables;
import lazySequences;
import sequences;

import shed.compiler.nodes;
import shed.compiler.nodes.NumberNode;
import shed.compiler.tokenising.tokens.Token;
import shed.compiler.parsing.results.ParseResult;
import shed.compiler.parsing.results.Success;
import shed.compiler.parsing.results.Failure;

val results = object {
    public def success fun[T] => (value: T, remaining: StringSource) =>
        Success[T](value, remaining);
        
    public def failure fun() =>
        Failure();
};

val rules = object {
    // TODO: should be type Rule = Fun(Sequence[Token]) => ParseResult
    def Rule class() => {}
    
    public def firstOf fun(name: String, rules: List[Rule]) =>
        fun(tokens: Sequence[Token]) => do {
            val results = lazySequenceables.map[Rule, ParseResult](
                fun(rule: Rule) => rule(tokens),
                rules
            );
            val successes = lazySequenceables.filter[ParseResult](
                fun(result: ParseResult) => result.isSuccess(),
                results
            );
            return sequenceables.head[ParseResult](successes)
                .valueOrElse[ParseResult](fun() => Failure());
        }
        
    public def tokenOfType fun(name: String) =>
        fun(tokens: Sequence[Token]) =>
            sequences.head[Token](tokens).map[Token, ParseResult](fun(token: Token) =>
                if token.name().equals(name) then do {
                    // TODO: should have function to get an option of both head and tail at the same time
                    return results.success[String](token.value(), tokens.tail());
                } else
                    results.failure()
            ).valueOrElse[ParseResult](fun() => results.failure())
    
    public def token fun(name: String, value: String) =>
        fun(tokens: Sequence[Token]) =>
            sequences.head[Token](tokens).map[ParseResult](fun(token: Token) =>
                if and(token.name().equals(name), tokens.value().equals(value)) then
                    results.success[String](token.value(), tokens.tail())
                else
                    results.failure()
            ).valueOrElse(fun() => results.failure())
    
    public def map fun[F, T] => (rule: Rule, func: Function[F, T]) =>
        fun(tokens: Sequence[Token]) =>
            rule(tokens).map[T](func)
};

public val expressions = object {
    def symbolRule fun(value: String) =>
        rules.token("symbol", value);
        
    val numberRule = rules.map[String, NumberNode](
        rules.tokenOfType("number"),
        nodes.number
    );
    
    //val unitRule = rules.map(
    //    rules.sequence(
    //        symbolRule("("),
    //        symbolRule(")")
    //    ),
    //    fun(_: Any) => nodes.unit()
    //);
    
    public val expressionRule = numberRule;
    
    public val expressionRule = rules.firstOf("expression",
        listOf(
            //unitRule,
            numberRule
        )
    );
};
