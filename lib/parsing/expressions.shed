module shed.compiler.parsing.expressions;

members {
    expressionRules
}

import lop.rules;
import lop.pratt;

import shed.compiler.nodes;
import shed.compiler.nodes.NumberNode;
import shed.compiler.nodes.UnitNode;
import shed.compiler.nodes.BooleanNode;

import shed.compiler.parsing.tokenRules;
import shed.compiler.parsing.literals;

val variableReferenceRule = rules.map(
    tokenRules.identifier(),
    nodes.variableReference
);
    
def expressionRules fun(statementRule: Rule[StatementNode]) => do {
    def ifThenElseRule fun(tokens: Sequence[Token]) =>
        rules.sequence()
            .next(tokenRules.keyword("if"))
            .cut()
            .capture(expressionRule)
            .next(tokenRules.keyword("then"))
            .capture(expressionRule)
            .next(tokenRules.keyword("else"))
            .capture(expressionRule)
            .map(nodes.ifThenElse)
            (tokens)

    def bracketedRule fun(tokens: Sequence[Token]) =>
        rules.sequence()
            .next(tokenRules.symbol("("))
            .capture(expressionRule)
            .cut()
            .next(tokenRules.symbol(")"))
            .head()
            (tokens)

    def functionRule fun(tokens: Sequence[Token]) =>
        rules.sequence()
            .next(tokenRules.keyword("fun"))
            .cut()
            .capture(formalArgumentListRule)
            .next(tokenRules.symbol("=>"))
            .capture(expressionRule)
            .map(nodes.function)
            (tokens)

    def formalArgumentListRule fun(tokens: Sequence[Token]) =>
        rules.sequence()
            .next(tokenRules.symbol("("))
            .capture(rules.zeroOrMoreWithSeparator(formalArgumentRule, tokenRules.symbol(",")))
            .next(tokenRules.symbol(")"))
            .head()
            (tokens)
            
    def formalArgumentRule fun(tokens: Sequence[Token]) =>
        rules.sequence()
            .capture(tokenRules.identifier())
            .cut()
            .next(tokenRules.symbol(":"))
            .capture(expressionRule)
            .map(nodes.formalArgument)
            (tokens)

    def memberDeclarationRule fun(tokens: Sequence[Token]) =>
        rules.sequence()
            .capture(tokenRules.identifier())
            .capture(rules.optional(expressionRule))
            .map(fun(name: String, value: Option[ExpressionNode]) =>
                nodes.memberDeclaration(name, value.valueOrElse(fun() => nodes.ref(name)))
            )
            (tokens)

    val membersRule =
        rules.sequence()
            .next(tokenRules.keyword("members"))
            .cut()
            .next(tokenRules.symbol("{"))
            .capture(rules.zeroOrMoreWithSeparator(memberDeclarationRule, tokenRules.symbol(",")))
            .next(tokenRules.symbol("}"))
            .head();

    val optionalMembersRule =
        rules.map(
            rules.optional(membersRule),
            fun(value: Option[List[MemberDeclarationNode]]) =>
                value.valueOrElse(fun() => emptyList)
        );
    
    val objectBodyRule =
        rules.sequence()
            .next(tokenRules.symbol("{"))
            .capture(optionalMembersRule)
            .capture(rules.zeroOrMore(statementRule))
            .next(tokenRules.symbol("}"))
            .map(nodes.obj);
    
    val classRule =
        rules.sequence()
            .next(tokenRules.keyword("class"))
            .cut()
            .capture(formalArgumentListRule)
            .next(tokenRules.symbol("=>"))
            .capture(objectBodyRule)
            .map(nodes.classDeclaration);
    
    val objectRule =
        rules.sequence()
            .next(tokenRules.keyword("object"))
            .cut()
            .capture(objectBodyRule)
            .head();

    val primaryExpressionRule = rules.firstOf("primary expression",
        listOf(
            literals.literalRule,
            variableReferenceRule,
            ifThenElseRule,
            bracketedRule,
            functionRule,
            objectRule,
            classRule
        )
    );
        
    def partialCallRule fun(tokens: Sequence[Token]) =>
        rules.sequence()
            .next(tokenRules.symbol("("))
            .cut()
            .capture(rules.zeroOrMoreWithSeparator(expressionRule, tokenRules.symbol(",")))
            .next(tokenRules.symbol(")"))
            .map(fun(args: List[ExpressionNode]) =>
                fun(left: ExpressionNode) => nodes.call(left, args))
            (tokens)
        
    def partialMemberAccessRule fun(tokens: Sequence[Token]) =>
        rules.sequence()
            .next(tokenRules.symbol("."))
            .cut()
            .capture(tokenRules.identifier())
            .map(fun(memberName: String) =>
                fun(left: ExpressionNode) => nodes.memberAccess(left, memberName))
            (tokens)

    val expressionParser = pratt.parser("expression",
        listOf(primaryExpressionRule),
        listOf(
            pratt.infix("call", partialCallRule),
            pratt.infix("memberAccess", partialMemberAccessRule)
        )
    );

    val expressionRule = expressionParser.rule();
    return object {
        members {
            expression fun() => expressionRule,
            membersRule fun() => membersRule
        }
    };  
}
