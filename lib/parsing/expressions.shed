package shed.compiler.parsing;

import shed.compiler.nodes;
import shed.compiler.nodes.NumberNode;
import shed.compiler.nodes.UnitNode;
import shed.compiler.nodes.BooleanNode;
import lop.rules;

public val expressions = object {
    def symbolRule fun(value: String) =>
        rules.token("symbol", value);
        
    val numberRule = rules.map[String, NumberNode](
        rules.tokenOfType("number"),
        nodes.number
    );
    
    val unitRule = rules.map[Unit, UnitNode](
        rules.sequence()
            .next(symbolRule("("))
            .next(symbolRule(")"))
            .end(),
        fun(_: Any) => nodes.unit()
    );
    
    val trueRule = rules.map[Unit, BooleanNode](
        rules.token("keyword", "true"),
        fun() => nodes.boolean(true)
    );
    
    val falseRule = rules.map[Unit, BooleanNode](
        rules.token("keyword", "false"),
        fun() => nodes.boolean(false)
    ); 
    
    val booleanRule = rules.firstOf("Boolean", listOf(trueRule, falseRule));
    
    public val expressionRule = rules.firstOf("expression",
        listOf(
            unitRule,
            numberRule,
            booleanRule
        )
    );
};
