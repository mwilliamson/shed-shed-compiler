module shed.compiler.codeGeneration.microJavaScript;

members {
    generate,
    Generator
}

import strings;

import shed.compiler.nodes;
import shed.compiler.javaScript.js;

val shed = nodes;
    
def generate fun(node: Node) =>
    Generator(generate).generate(node)

def Generator class(generate: Function[ShedNode, JavaScriptNode]) => {
    members {
        generate generatorGenerate
    }
    
    val shedGlobal = js.ref("$shed");
    
    def generatorGenerate fun(node: ShedNode) =>
        match(node,
            matchClass(shed.UnitNode, unit),
            matchClass(shed.BooleanNode, bool),
            matchClass(shed.NumberNode, number),
            matchClass(shed.StringNode, string),
            matchClass(shed.VariableReferenceNode, variableReference),
            matchClass(shed.IfThenElseNode, ifThenElse),
            matchClass(shed.CallNode, call),
            matchClass(shed.MemberAccessNode, memberAccess),
            matchClass(shed.FunctionNode, func),
            matchClass(shed.ClassNode, classDeclaration),
            matchClass(shed.ObjectNode, obj),
            matchClass(shed.DoBlockNode, doBlock),
            
            matchClass(shed.ExpressionStatementNode, expressionStatement),
            matchClass(shed.ReturnStatementNode, returnStatement),
            matchClass(shed.ValDeclarationNode, valDeclaration),
            matchClass(shed.DefinitionNode, definition),
            
            matchClass(shed.ImportNode, importNode),
            matchClass(shed.ModuleNode, moduleNode)
        )

    def unit fun(unit: UnitNode) =>
        js.propertyAccess(shedGlobal, "unit")

    def bool fun(bool: BooleanNode) =>
        js.bool(bool.value())

    def number fun(number: NumberNode) =>
        js.call(
            js.propertyAccess(shedGlobal, "number"),
            listOf(js.number(number.value()))
        )

    def string fun(string: StringNode) =>
        js.call(
            js.propertyAccess(shedGlobal, "string"),
            listOf(js.string(string.value()))
        )

    def variableReference fun(variableReference: VariableReferenceNode) =>
        js.ref(variableReference.identifier())
    
    def ifThenElse fun(ifThenElse: IfThenElseNode) =>
        js.conditional(
            generate(ifThenElse.condition()),
            generate(ifThenElse.trueValue()),
            generate(ifThenElse.falseValue())
        )
    
    def call fun(call: CallNode) =>
        js.call(generate(call.callee()), call.args().map(generate))
    
    def memberAccess fun(memberAccess: MemberAccessNode) =>
        js.propertyAccess(generate(memberAccess.left()), memberAccess.memberName())

    def func fun(func: FunctionNode) =>
        js.call(
            js.propertyAccess(shedGlobal, "function"),
            listOf(js.func(
                generateFormalArgs(func.formalArgs()),
                listOf(js.ret(generate(func.body())))
            ))
        )
        
    def classDeclaration fun(classDeclaration: ClassNode) =>
        js.call(
            js.propertyAccess(shedGlobal, "class"),
            listOf(js.func(
                generateFormalArgs(classDeclaration.formalArgs()),
                generateObjectBody(classDeclaration.body())
            ))
        )
        
    def obj fun(obj: ObjectNode) =>
        js.call(
            generate(shed.classDeclaration(emptyList, obj)),
            emptyList
        )

    def doBlock fun(doBlock: DoBlockNode) =>
        js.call(
            js.func(
                emptyList,
                doBlock.statements().map(generate)  
            ),
            emptyList
        )

    def expressionStatement fun(expressionStatement: ExpressionStatementNode) =>
        js.expressionStatement(generate(expressionStatement.expression()))
    
    def returnStatement fun(returnStatement: ReturnStatementNode) =>
        js.ret(generate(returnStatement.value()))
        
    def valDeclaration fun(valDeclaration: ValDeclarationNode) =>
        js.varDeclaration(
            valDeclaration.name(),
            generate(valDeclaration.value())
        )
    
    def definition fun(definition: DefinitionNode) =>
        js.varDeclaration(
            definition.name(),
            js.call(
                js.propertyAccess(generate(definition.value()), "$define"),
                listOf(js.string(definition.name()))
            )
        )
    
    def importNode fun(importNode: ImportNode) =>
        js.varDeclaration(
            importNode.moduleName().last(),
            js.call(
                js.ref("$import"),
                listOf(js.string(strings.join(".", importNode.moduleName())))
            )
        )
    
    def moduleNode fun(moduleNode: ModuleNode) =>
        moduleNode.name()
            .map(fun(name: List[String]) => generateNamedModule(name, moduleNode))
            .valueOrElse(fun() => generateUnnamedModule(moduleNode))

    def generateFormalArgs fun(formalArgs: List[FormalArgumentNode]) =>
        formalArgs.map(fun(arg: FormalArgumentNode) => arg.name())

    def generateObjectBody fun(body: ObjectNode) =>
        body.statements().map(generate)
            .concat(listOf(js.ret(generateMembersObject(body.memberDeclarations()))))
            
    def generateMembersObject fun(membersDeclaration: List[MemberDeclarationNode]) =>
        js.obj(membersDeclaration.map(fun(memberDeclaration: MemberDeclarationNode) =>
            tuple(memberDeclaration.name(), generate(memberDeclaration.value()))
        ))
        
    def generateNamedModule fun(name: List[String], moduleNode: ModuleNode) =>
        js.expressionStatement(
            js.call(
                js.propertyAccess(shedGlobal, "exportModule"),
                listOf(
                    js.string(strings.join(".", name)),
                    js.func(
                        emptyList,
                        moduleNode.statements().map(generate)
                            .concat(listOf(js.ret(generateMembersObject(moduleNode.memberDeclarations()))))
                    )
                )
            )
        )
    
    def generateUnnamedModule fun(moduleNode: ModuleNode) =>
        js.call(
            js.func(
                emptyList,
                moduleNode.statements().map(generate)
            ),
            emptyList
        )
}
