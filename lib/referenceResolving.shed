module shed.compiler.referenceResolving;

members {
    resolveReferences,
    emptyContext,
    variableNotInScope
}

import sequences;

import shed.compiler.results;
import shed.compiler.nodes;

def resolveReferences fun(node: ShedNode, context: Context) => do {
    def resolveRef fun(ref: VariableReferenceNode) => let
        val name = ref.identifier()
        in if context.contains(name) then
            results.success(())
        else
            results.failure(listOf(variableNotInScope(name)))
    
    def resolveFunction fun(func: FunctionNode) => let
        val bodyContext = func.formalArgs().foldLeft(
            context,
            fun(currentContext: Context, arg: FormalArgument) =>
                currentContext.add(arg.name())
        )
        in resolveReferences(func.body(), bodyContext)
    
    def resolveChildren fun(node: ShedNode) =>
        if isList(node) then
            resolveAll(node)
        else if node.struct then
            resolveAll(node.struct().fields())
        else
            results.success(())
    
    def resolveAll fun(objects: List[Any]) =>
        objects.foldLeft(results.success(()), fun(result: Result, child: Any) =>
            if result.isSuccess() then
                resolveReferences(child, context)
            else
                result
        )
        
    def isList fun(obj: Any) => equal(classOf(obj), classOf(listOf()))
    
    return if classOf(node) && classOf(node).equals then
        match(node,
            matchClass(nodes.VariableReferenceNode, resolveRef),
            matchClass(nodes.FunctionNode, resolveFunction),
            matchDefault(resolveChildren)
        )
    else
        results.success(());
}

def variableNotInScope fun(name: String) =>
    "variable not in scope: ".concat(name)

def Context class(names: Sequence[String]) => {
    members {
        contains,
        add
    }
    
    def contains fun(name: String) =>
        sequences.any(fun(n: String) => n.equals(name), names)
        
    def add fun(name: String) =>
        Context(sequences.cons(name, names))
}

val emptyContext = Context(sequences.nil);

