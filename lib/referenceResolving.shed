module shed.compiler.referenceResolving;

members {
    resolveReferences,
    emptyContext,
    variableNotInScope
}

import sequences;

import shed.compiler.results;
import shed.compiler.nodes;
import shed.compiler.scoping;

def resolveReferences fun(node: ShedNode, context: Context) => do {
    def resolveRef fun(ref: VariableReferenceNode) => let
        val name = ref.identifier()
        in if context.contains(name) then
            results.success(context)
        else
            results.failure(listOf(variableNotInScope(name)))
    
    def resolveFunction fun(func: FunctionNode) => let
        val bodyContext = func.formalArgs().foldLeft(
            context,
            fun(currentContext: Context, arg: FormalArgument) =>
                currentContext.add(arg.name())
        )
        in resolveAll(func.formalArgs().concat(listOf(func.body())), bodyContext)
    
    def resolveNode fun(node: ShedNode) => let
        val scope = scoping.scopeOf(node)
        val result = if classOf(node).equals(nodes.VariableReferenceNode) then
            resolveRef(node)
        else
            results.success(context)
            
        in result.bind(fun(context: Context) => resolveScope(scope, context))
    
    return match(node,
        matchClass(nodes.FunctionNode, resolveFunction),
        
        matchDefault(resolveNode)
    );
}
        
def resolveScope fun(scope: SameScope, context: Context) =>
    resolveAll(scope.nodes(), context)

def resolveAll fun(nodes: List[ShedNode], context: Context) =>
    nodes.foldLeft(results.success(context), fun(result: Result, child: ShedNode) =>
        if result.isSuccess() then
            resolveReferences(child, context)
        else
            result
    )

def variableNotInScope fun(name: String) =>
    "variable not in scope: ".concat(name)

def Context class(names: Sequence[String]) => {
    members {
        contains,
        add
    }
    
    def contains fun(name: String) =>
        sequences.any(fun(n: String) => n.equals(name), names)
        
    def add fun(name: String) =>
        Context(sequences.cons(name, names))
}

val emptyContext = Context(sequences.nil);

