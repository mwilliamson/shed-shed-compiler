module shed.compiler.referenceResolving;

members {
    resolveReferences,
    emptyContext,
    variableNotInScope
}

import sequences;

import shed.compiler.results;
import shed.compiler.nodes;
import shed.compiler.scoping;

def resolveReferences fun(node: ShedNode, context: Context) => do {
    def resolveRef fun(ref: VariableReferenceNode) => let
        val name = ref.identifier()
        in if context.contains(name) then
            results.success(())
        else
            results.failure(listOf(variableNotInScope(name)))
    
    def resolveFunction fun(func: FunctionNode) => let
        val bodyContext = func.formalArgs().foldLeft(
            context,
            fun(currentContext: Context, arg: FormalArgument) =>
                currentContext.add(arg.name())
        )
        in resolveAll(func.formalArgs().concat(listOf(func.body())), bodyContext)
    
    def resolveFormalArgument fun(formalArg: FormalArgumentNode) =>
        resolveReferences(formalArg.type(), context)
    
    def resolveScope fun(node: ShedNode) => let
        val scope = scoping.scopeOf(node)
        in match(scope,
            matchClass(scoping.SameScope, resolveSameScope)
        )
        
    def resolveSameScope fun(scope: SameScope) =>
        resolveAll(scope.nodes(), context)
    
    return match(node,
        matchClass(nodes.FormalArgumentNode, resolveFormalArgument),
        
        matchClass(nodes.VariableReferenceNode, resolveRef),
        matchClass(nodes.FunctionNode, resolveFunction),
        
        matchDefault(resolveScope)
    );
}

def resolveAll fun(nodes: List[ShedNode], context: Context) =>
    nodes.foldLeft(results.success(()), fun(result: Result, child: ShedNode) =>
        if result.isSuccess() then
            resolveReferences(child, context)
        else
            result
    )

def variableNotInScope fun(name: String) =>
    "variable not in scope: ".concat(name)

def Context class(names: Sequence[String]) => {
    members {
        contains,
        add
    }
    
    def contains fun(name: String) =>
        sequences.any(fun(n: String) => n.equals(name), names)
        
    def add fun(name: String) =>
        Context(sequences.cons(name, names))
}

val emptyContext = Context(sequences.nil);

