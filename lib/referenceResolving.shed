module shed/compiler/referenceResolving;

members::
    resolveReferences,
    emptyContext,
    variableNotInScope

import sequences;

import lop/sources

import shed/compiler/results
import shed/compiler/nodes
import shed/compiler/scoping
import shed/compiler/phases

def resolveReferences fun(node: ShedNode, context: Context) => let
    val result = if classOf(node).equals(nodes.VariableReferenceNode) then
        resolveRef(node, context)
    else
        results.success(context)
    
    val resultUpdatedContext = if isVariableBinder(node) then
        result.map(fun(context: Context) =>
            if classOf(node).equals(nodes.FormalParameterNode) then
                context.addCompileTime(node.name())
            else
                context.addRunTime(node.name())
        )
    else
        result
    
    val scope = scoping.scopeOf(node)
    in resultUpdatedContext.bind(fun(context: Context) => resolveScope(scope, context))

def resolveRef fun(ref: VariableReferenceNode, context: Context) => let
    val name = ref.identifier()
    in if context.contains(name) then
        results.success(context)
    else
        results.failure(listOf(variableNotInScope(ref)))

def isVariableBinder fun(node: ShedNode) =>
    // TODO: introduce a VariableBinderNode interface to remove this logic
    match(node,
        matchClass(nodes.FormalParameterNode, fun() => true),
        matchClass(nodes.FormalArgumentNode, fun() => true),
        matchClass(nodes.ValDeclarationNode, fun() => true),
        matchClass(nodes.DefinitionNode, fun() => true),
        matchClass(nodes.ImportNode, fun() => true),
        matchDefault(fun() => false)
    )

def resolveScope fun(scope: Scope, context: Context) =>
    if classOf(scope).equals(scoping.ChangePhase) then
        resolveScope(scope.scope(), context.changePhase(scope.phase()))
            .map(fun(newContext) => newContext.changePhase(context.phase()))
    else let 
        val result = resolveAll(scope.nodes(), context)
        in match(scope,
            matchClass(scoping.SameScope, fun(scope: SameScope) => result),
            matchClass(scoping.SubScope, fun(scope: SubScope) =>
                result.map(fun(subContext: Context) => context)
            )
        )
    

def resolveAll fun(nodes: List[ShedNode], context: Context) =>
    nodes.foldLeft(results.success(context), fun(result: Result, child: ShedNode) =>
        result.bind(fun(context: Context) => resolveReferences(child, context))
    )

def variableNotInScope fun(ref: VariableReferenceNode) => let
    val mainMessage = "variable not in scope: ".concat(ref.identifier())
    val suffix = sources.tryGetSource(ref)
        .map(fun(source) => "\n".concat(source.describe()))
        .valueOrElse(fun() => "")
    in mainMessage.concat(suffix)
        

def Context class(bindings: Sequence[Binding], phase: phases.Phase) => ::
    members::
        contains,
        addRunTime,
        addCompileTime,
        add,
        changePhase,
        phase fun() => phase
    
    def contains fun(name: String) => let
        // TODO: grab the first binding regardless of phase
        val isMatchingBinding = fun(binding: Binding) =>
            binding.name().equals(name) && phase.lessThanOrEqual(binding.phase())
        in sequences.any(isMatchingBinding, bindings)
    
    def addRunTime fun(name: String) =>
        add(name, phases.runTime)
    
    def addCompileTime fun(name: String) =>
        add(name, phases.compileTime)
    
    def add fun(name: String, phase: Phase) =>
        Context(sequences.cons(Binding(name, phase), bindings), phase)
    
    def changePhase fun(newPhase: phases.Phase) =>
        Context(bindings, newPhase)
    
val emptyContext = Context(sequences.nil, phases.runTime);

def Binding class(name: String, phase: phases.Phase) => ::
    members ::
        name fun() => name
        phase fun() => phase
