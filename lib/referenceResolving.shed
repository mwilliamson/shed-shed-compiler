module shed.compiler.referenceResolving;

members {
    resolveReferences,
    emptyContext,
    variableNotInScope
}

import sequences;

import shed.compiler.results;
import shed.compiler.nodes;

def resolveReferences fun(node: ShedNode, context: Context) => do {
    def resolveRef fun(ref: VariableReferenceNode) => let
        val name = ref.identifier()
        in if context.contains(name) then
            results.success(())
        else
            results.failure(listOf(variableNotInScope(name)))
    
    def resolveFunction fun(func: FunctionNode) => let
        val bodyContext = func.formalArgs().foldLeft(
            context,
            fun(currentContext: Context, arg: FormalArgument) =>
                currentContext.add(arg.name())
        )
        in resolveReferences(func.body(), bodyContext)
    
    def resolveLiteral fun(literal: LiteralNode) =>
        results.success(())
    
    def resolveChildren fun[T] => (childrenFinder: Function[T, List[ShedNode]]) =>
        fun(node: T) => let
            val children = childrenFinder(node)
            in children.foldLeft(results.success(()), fun(result: Result, child: ShedNode) =>
                if result.isSuccess() then
                    resolveReferences(child, context)
                else
                    result
            )
    
    return match(node,
        matchClass(nodes.UnitNode, resolveLiteral),
        matchClass(nodes.NumberNode, resolveLiteral),
        matchClass(nodes.StringNode, resolveLiteral),
        matchClass(nodes.BooleanNode, resolveLiteral),
        
        matchClass(nodes.IfThenElseNode, resolveChildren(ifChildren)),
        
        matchClass(nodes.VariableReferenceNode, resolveRef),
        matchClass(nodes.FunctionNode, resolveFunction)
    );
}

def ifChildren fun(node: IfThenElseNode) =>
    listOf(node.condition(), node.trueValue(), node.falseValue())

def variableNotInScope fun(name: String) =>
    "variable not in scope: ".concat(name)

def Context class(names: Sequence[String]) => {
    members {
        contains,
        add
    }
    
    def contains fun(name: String) =>
        sequences.any(fun(n: String) => n.equals(name), names)
        
    def add fun(name: String) =>
        Context(sequences.cons(name, names))
}

val emptyContext = Context(sequences.nil);

