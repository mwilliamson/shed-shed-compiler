module shed.compiler.javaScript.writing;

members {
    write
}

import json;
import strings;

import shed.compiler.javaScript.js;

def write fun(javaScriptNode: JavaScriptNode) =>
    match(javaScriptNode,
        matchClass(js.BooleanNode, writeBoolean),
        matchClass(js.NumberNode, writeNumber),
        matchClass(js.StringNode, writeString),
        matchClass(js.VariableReferenceNode, writeVariableReference),
        matchClass(js.ConditionalOperatorNode, writeConditionalOperator),
        matchClass(js.CallNode, writeCall),
        matchClass(js.PropertyAccessNode, writePropertyAccess),
        
        matchClass(js.ExpressionStatementNode, writeExpressionStatement),
        matchClass(js.ReturnNode, writeReturn),
        
        matchClass(js.StatementsNode, writeStatements)
    )
    
def writeBoolean fun(boolean: BooleanNode) =>
    if boolean.value() then "true" else "false"
    
def writeNumber fun(number: NumberNode) =>
    number.value()
    
def writeString fun(string: StringNode) =>
    json.stringifyString(string.value())
    
def writeVariableReference fun(ref: VariableReferenceNode) =>
    ref.identifier()
    
def writeConditionalOperator fun(conditional: ConditionalOperatorNode) =>
    write(conditional.condition())
        .concat(" ? ")
        .concat(write(conditional.trueValue()))
        .concat(" : ")
        .concat(write(conditional.falseValue()))
    
def writeCall fun(call: CallNode) =>
    write(call.callee())
        .concat("(")
        .concat(strings.join(", ", call.args().map(write)))
        .concat(")")
        
def writePropertyAccess fun(propertyAccess: PropertyAccessNode) =>
    write(propertyAccess.left())
        .concat(".")
        .concat(propertyAccess.propertyName())
    
def writeExpressionStatement fun(expressionStatement: ExpressionStatementNode) =>
    write(expressionStatement.expression()).concat(";")

def writeReturn fun(returnStatement: ReturnNode) =>
    "return ".concat(write(returnStatement.value())).concat(";")

def writeStatements fun(statements: StatementsNode) =>
    strings.join("\n", statements.statements().map(write))
