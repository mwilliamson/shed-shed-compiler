module shed.compiler.javaScript.writing;

members {
    write
}

import json;
import strings;

import shed.compiler.javaScript.js;

val lowestPrecedence = 100;

def write fun(javaScriptNode: JavaScriptNode) =>
    writeWithPrecedence(javaScriptNode, lowestPrecedence)

def writeWithPrecedence fun(javaScriptNode: JavaScriptNode, precedence: Double) =>
    match(javaScriptNode,
        matchClass(js.BooleanNode, writeBoolean),
        matchClass(js.NumberNode, writeNumber),
        matchClass(js.StringNode, writeString),
        matchClass(js.VariableReferenceNode, writeVariableReference),
        matchClass(js.ConditionalOperatorNode, writeExpression(conditionalOperatorWriter, precedence)),
        matchClass(js.CallNode, writeCall),
        matchClass(js.PropertyAccessNode, writePropertyAccess),
        matchClass(js.FunctionNode, writeExpression(functionWriter, precedence)),
        matchClass(js.ObjectNode, writeObject),
        
        matchClass(js.ExpressionStatementNode, writeExpressionStatement),
        matchClass(js.ReturnNode, writeReturn),
        matchClass(js.VarDeclarationNode, writeVar),
        
        matchClass(js.StatementsNode, writeStatements)
    )

def writeExpression fun[T] => (expressionType: ExpressionType[T], precedence: Double) =>
    fun(node: T) => do {
        def subWrite fun(node: JavaScriptNode) =>
            writeWithPrecedence(node, expressionType.precedence)
            
        val innerString = expressionType.write(subWrite, node);
        return if precedence.lessThanOrEqual(expressionType.precedence) then
            "(".concat(innerString).concat(")")
        else
            innerString;
    }

val conditionalOperatorWriter = object {
    members {
        precedence 15,
        write writeConditionalOperator
    }
    
    def writeConditionalOperator fun(write: Function[JavaScriptNode, String], conditional: ConditionalOperatorNode) =>
        write(conditional.condition())
            .concat(" ? ")
            .concat(write(conditional.trueValue()))
            .concat(" : ")
            .concat(write(conditional.falseValue()))
};

def writeBoolean fun(bool: BooleanNode) =>
    if bool.value() then "true" else "false"
    
def writeNumber fun(number: NumberNode) =>
    number.value()
    
def writeString fun(string: StringNode) =>
    json.stringifyString(string.value())
    
def writeVariableReference fun(ref: VariableReferenceNode) =>
    ref.identifier()
    
def writeCall fun(call: CallNode) =>
    writeWithPrecedence(call.callee(), 2)
        .concat("(")
        .concat(strings.join(", ", call.args().map(write)))
        .concat(")")
        
def writePropertyAccess fun(propertyAccess: PropertyAccessNode) =>
    writeWithPrecedence(propertyAccess.left(), 1)
        .concat(".")
        .concat(propertyAccess.propertyName())

val functionWriter = object {
    members {
        precedence 20,
        write writeFunction
    }
    
    def writeFunction fun(write: Function[JavaScriptNode, String], func: FunctionNode) =>
        "function("
            .concat(strings.join(", ", func.formalArgs()))
            .concat(") {")
            .concat(writeIndentedStatements(func.statements()))
            .concat("\n}")
};

def writeIndentedStatements fun(statements: List[StatementNode]) =>
    strings.join(
        "",
        statements
            .map(write)
            .map(fun(statement: String) => "\n    ".concat(statement))
    )

def writeObject fun(obj: ObjectNode) =>
    "{"
        .concat(strings.join(",", obj.properties().map(writeProperty)))
        .concat("\n}")

def writeProperty fun(property: Tuple[String, ExpressionNode]) =>
    property.map(fun(name: String, value: ExpressionNode) =>
        "\n    ".concat(name).concat(": ").concat(write(value))
    )

def writeExpressionStatement fun(expressionStatement: ExpressionStatementNode) =>
    write(expressionStatement.expression()).concat(";")

def writeReturn fun(returnStatement: ReturnNode) =>
    "return ".concat(write(returnStatement.value())).concat(";")

def writeVar fun(varDeclaration: VarDeclarationNode) =>
    "var "
        .concat(varDeclaration.name())
        .concat(" = ")
        .concat(write(varDeclaration.initialValue()))
        .concat(";")

def writeStatements fun(statements: StatementsNode) =>
    strings.join("\n", statements.statements().map(write))
