package shed.compiler.parsing;

import sequences;
import strings;
import lazySequences;

import hat.TestCase;
import duck.assertThat;
import duck.isList;
import duck.equalTo;
import duck.MatchResult;

import shed.compiler.parsing.rules;
import shed.compiler.parsing.results.Success;
import shed.compiler.tokenising.Token;
import shed.compiler.StringSource;
import shed.compiler.strings.createStringSource;
import shed.compiler.parsing.testing.isSuccess;
import shed.compiler.parsing.testing.isFailure;

def source fun(value: String) => createStringSource(value, "raw string");

public val rulesTest = listOf[TestCase](
    TestCase("rules.token fails if input token is of wrong type", fun() =>
        assertFailedParse[String](
            rules.token("identifier", "true"),
            listOf(Token("keyword", "true", source("true")))
        )
    ),
    
    TestCase("rules.token fails if input token has wrong value", fun() =>
        assertFailedParse[String](
            rules.token("identifier", "true"),
            listOf(Token("identifier", "false", source("false")))
        )
    ),
    
    TestCase("rules.token succeeds if type and value match", fun() =>
        assertSuccessfulParse[String](
            rules.token("identifier", "true"),
            listOf(Token("identifier", "true", source("true"))),
            "true"
        )
    )
);
    
def stringSource fun(string: String) =>
    createStringSource(string, "raw string");

def assertFailedParse fun[T] => (rule: Rule[T], input: List[Token]) => do {
    return assertParse[T](rule, input, isFailure);
};

def assertSuccessfulParse fun[T] => (rule: Rule[T], input: List[Token], value: T) => do {
    return assertParse[T](rule, input, isSuccess[T](value));
};

def assertParse fun[T] => (rule: Rule[T], input: List[Token], matcher: Matcher) => do {
    val result = rule(input.toSequence());
    return assertThat[T](result, matcher);
};
