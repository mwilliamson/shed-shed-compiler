package shed.compiler.parsing;

import sequences;
import strings;
import lazySequences;

import hat.TestCase;
import duck.assertThat;
import duck.isList;
import duck.equalTo;
import duck.MatchResult;

import lop.StringSource;
import lop.Range;
import lop.strings.createStringSource;
import shed.compiler.nodes;
import shed.compiler.nodes.Node;
import lop.Token;
import shed.compiler.parsing.Parser;
import shed.compiler.parsing.expressions;
import lop.results.Success;
import lop.testing.isSuccess;

public val expressionsTest = listOf[TestCase](
    TestCase("can parse unit", fun() =>
        assertSuccessfulParse("()", nodes.unit())
    ),
    
    TestCase("can parse number literal", fun() =>
        assertSuccessfulParse("42", nodes.number("42"))
    ),
    
    TestCase("can parse true literal", fun() =>
        assertSuccessfulParse("true", nodes.boolean(true))
    ),
    
    TestCase("can parse false literal", fun() =>
        assertSuccessfulParse("false", nodes.boolean(false))
    ),
    
    TestCase("can parse string literal", fun() =>
        assertSuccessfulParse("\"blah\"", nodes.string("blah"))
    ),
    
    TestCase("can parse variable reference", fun() =>
        assertSuccessfulParse("blah", nodes.variableReference("blah"))
    ),
    
    TestCase("can parse bracketed expression", fun() =>
        assertSuccessfulParse("(false)", nodes.boolean(false))
    ),
    
    TestCase("can parse function call with no arguments", fun() =>
        assertSuccessfulParse("go()", nodes.call(nodes.ref("go"), emptyList))
    ),
    
    TestCase("can parse function call with one argument", fun() =>
        assertSuccessfulParse(
            "print(\"Hello\")",
            nodes.call(nodes.ref("print"), listOf(nodes.string("Hello")))
        )
    ),
    
    TestCase("can parse function call with multiple arguments", fun() =>
        assertSuccessfulParse(
            "equal(1,2)",
            nodes.call(nodes.ref("equal"), listOf(nodes.number("1"), nodes.number("2")))
        )
    )
);
    
def stringSource fun(string: String) =>
    createStringSource(string, "raw string");
    
def parse fun(input: StringSource) =>
    Parser().parse(expressions.expression, input);

def assertSuccessfulParse fun(input: String, expected: Node) => do {
    val source = stringSource(input);
    val result = Parser().parse(expressions.expressionRule, source);
    return assertThat[Node](result, isSuccess[Node](equalTo[Node](expected)));
}
