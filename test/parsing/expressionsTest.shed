module shed.compiler.parsing.expressionsTest;

members {
    testCases
}

import hat.TestCase;
import lop.rules;

import shed.compiler.nodes;
import shed.compiler.nodes.Node;
import shed.compiler.parsing.expressions.expressionRules;
import shed.compiler.parsing.testing.createAssertSuccessfulParse;

val testCases = listOf[TestCase](
    TestCase("can parse variable reference", fun() =>
        assertSuccessfulParse("blah", nodes.variableReference("blah"))
    ),
    
    TestCase("can parse if-then-else expression", fun() =>
        assertSuccessfulParse(
            "if true then 1 else 0",
            nodes.ifThenElse(
                nodes.bool(true),
                nodes.number("1"),
                nodes.number("0")
            )
        )
    ),
    
    TestCase("can parse nested if-then-else expressions", fun() =>
        assertSuccessfulParse(
            "if true then 1 else if false then 0 else 2",
            nodes.ifThenElse(
                nodes.bool(true),
                nodes.number("1"),
                nodes.ifThenElse(
                    nodes.bool(false),
                    nodes.number("0"),
                    nodes.number("2")
                )
            )
        )
    ),
    
    TestCase("can parse bracketed expression", fun() =>
        assertSuccessfulParse("(false)", nodes.bool(false))
    ),
    
    TestCase("can parse function call with no arguments", fun() =>
        assertSuccessfulParse("go()", nodes.call(nodes.ref("go"), emptyList))
    ),
    
    TestCase("can parse function call with one argument", fun() =>
        assertSuccessfulParse(
            "print(\"Hello\")",
            nodes.call(nodes.ref("print"), listOf(nodes.string("Hello")))
        )
    ),
    
    TestCase("can parse function call with multiple arguments", fun() =>
        assertSuccessfulParse(
            "equal(1,2)",
            nodes.call(nodes.ref("equal"), listOf(nodes.number("1"), nodes.number("2")))
        )
    ),
    
    TestCase("can parse repeated function calls", fun() =>
        assertSuccessfulParse(
            "go()()()",
            nodes.call(nodes.call(nodes.call(nodes.ref("go"), emptyList), emptyList), emptyList)
        )
    ),
    
    TestCase("can parse type application", fun() =>
        assertSuccessfulParse(
            "Dictionary[String, Number]",
            nodes.typeApplication(
                nodes.ref("Dictionary"),
                listOf(nodes.ref("String"), nodes.ref("Number"))
            )
        )
    ),
    
    TestCase("can parse member access", fun() =>
        assertSuccessfulParse(
            "bob.name",
            nodes.memberAccess(nodes.ref("bob"), "name")
        )
    ),
    
    TestCase("can parse function with no arguments", fun() =>
        assertSuccessfulParse(
            "fun() => ()",
            nodes.func(
                emptyList,
                nodes.unit()
            )
        )
    ),
    
    TestCase("can parse function with formal arguments", fun() =>
        assertSuccessfulParse(
            "fun(first: String, second: Any) => ()",
            nodes.func(
                listOf(
                    nodes.formalArgument("first", nodes.ref("String")),
                    nodes.formalArgument("second", nodes.ref("Any"))
                ),
                nodes.unit()
            )
        )
    ),
    
    TestCase("can parse function with formal type parameters", fun() =>
        assertSuccessfulParse(
            "fun[T] => () => ()",
            nodes.func(
                emptyList,
                nodes.unit()
            )
        )
    ),
    
    TestCase("can parse empty object", fun() =>
        assertSuccessfulParse(
            "object { }",
            nodes.obj(
                emptyList,
                emptyList
            )
        )
    ),
    
    TestCase("can parse object with body", fun() =>
        assertSuccessfulParse(
            "object { x y }",
            nodes.obj(
                emptyList,
                listOf(stubStatement("x"), stubStatement("y"))
            )
        )
    ),
    
    TestCase("can parse object with members", fun() =>
        assertSuccessfulParse(
            "object { members { x } x y }",
            nodes.obj(
                listOf(nodes.memberDeclaration("x", nodes.ref("x"))),
                listOf(stubStatement("x"), stubStatement("y"))
            )
        )
    ),
    
    TestCase("can parse empty class", fun() =>
        assertSuccessfulParse(
            "class() => { }",
            nodes.classDeclaration(
                emptyList,
                nodes.obj(emptyList, emptyList)
            )
        )
    ),
    
    TestCase("can parse class with body", fun() =>
        assertSuccessfulParse(
            "class() => { members { x } x y }",
            nodes.classDeclaration(
                emptyList,
                nodes.obj(
                    listOf(nodes.memberDeclaration("x", nodes.ref("x"))),
                    listOf(stubStatement("x"), stubStatement("y"))
                )
            )
        )
    ),
                
    TestCase("can parse class with formal arguments", fun() =>
        assertSuccessfulParse(
            "class(first: String, second: Any) => {}",
            nodes.classDeclaration(
                listOf(
                    nodes.formalArgument("first", nodes.ref("String")),
                    nodes.formalArgument("second", nodes.ref("Any"))
                ),
                nodes.obj(emptyList, emptyList)
            )
        )
    ),
    
    TestCase("can parse class with formal type parameters", fun() =>
        assertSuccessfulParse(
            "class[T] => () => { }",
            nodes.classDeclaration(
                emptyList,
                nodes.obj(emptyList, emptyList)
            )
        )
    ),
    
    TestCase("members can be empty", fun() =>
        assertSuccessfulMembersParse(
            "members { }",
            emptyList
        )
    ),
    
    TestCase("members can be declared inline", fun() =>
        assertSuccessfulMembersParse(
            "members { x 1 }",
            listOf(nodes.memberDeclaration("x", nodes.number("1")))
        )
    ),
    
    TestCase("members can be declared from outer scope", fun() =>
        assertSuccessfulMembersParse(
            "members { x }",
            listOf(nodes.memberDeclaration("x", nodes.ref("x")))
        )
    ),
                
    TestCase("can parse do block", fun() =>
        assertSuccessfulParse(
            "do { x y }",
            nodes.doBlock(
                listOf(
                    stubStatement("x"),
                    stubStatement("y")
                )
            )
        )
    )
);
    
def stubStatement fun(name: String) =>
    nodes.expressionStatement(nodes.ref(name))

val statementRule =
    rules.map(
        rules.tokenOfType("identifier"),
        stubStatement
    );

val assertSuccessfulParse = createAssertSuccessfulParse(expressionRules(statementRule).expression());

// TODO: members should be in their own module?
val assertSuccessfulMembersParse =
    createAssertSuccessfulParse(expressionRules(statementRule).membersRule());
