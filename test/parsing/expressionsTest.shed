module shed.compiler.parsing.expressionsTest;

members {
    testCases
}

import hat.TestCase;
import duck.assertThat;
import duck.equalTo;

import lop.strings.createStringSource;
import lop.testing.isSuccess;

import shed.compiler.nodes;
import shed.compiler.nodes.Node;
import shed.compiler.parsing.parser.Parser;
import shed.compiler.parsing.expressions;

val testCases = listOf[TestCase](
    TestCase("can parse unit", fun() =>
        assertSuccessfulParse("()", nodes.unit())
    ),
    
    TestCase("can parse number literal", fun() =>
        assertSuccessfulParse("42", nodes.number("42"))
    ),
    
    TestCase("can parse true literal", fun() =>
        assertSuccessfulParse("true", nodes.boolean(true))
    ),
    
    TestCase("can parse false literal", fun() =>
        assertSuccessfulParse("false", nodes.boolean(false))
    ),
    
    TestCase("can parse string literal", fun() =>
        assertSuccessfulParse("\"blah\"", nodes.string("blah"))
    ),
    
    TestCase("can parse variable reference", fun() =>
        assertSuccessfulParse("blah", nodes.variableReference("blah"))
    ),
    
    TestCase("can parse if-then-else expression", fun() =>
        assertSuccessfulParse(
            "if true then 1 else 0",
            nodes.ifThenElse(
                nodes.boolean(true),
                nodes.number("1"),
                nodes.number("0")
            )
        )
    ),
    
    TestCase("can parse nested if-then-else expressions", fun() =>
        assertSuccessfulParse(
            "if true then 1 else if false then 0 else 2",
            nodes.ifThenElse(
                nodes.boolean(true),
                nodes.number("1"),
                nodes.ifThenElse(
                    nodes.boolean(false),
                    nodes.number("0"),
                    nodes.number("2")
                )
            )
        )
    ),
    
    TestCase("can parse bracketed expression", fun() =>
        assertSuccessfulParse("(false)", nodes.boolean(false))
    ),
    
    TestCase("can parse function call with no arguments", fun() =>
        assertSuccessfulParse("go()", nodes.call(nodes.ref("go"), emptyList))
    ),
    
    TestCase("can parse function call with one argument", fun() =>
        assertSuccessfulParse(
            "print(\"Hello\")",
            nodes.call(nodes.ref("print"), listOf(nodes.string("Hello")))
        )
    ),
    
    TestCase("can parse function call with multiple arguments", fun() =>
        assertSuccessfulParse(
            "equal(1,2)",
            nodes.call(nodes.ref("equal"), listOf(nodes.number("1"), nodes.number("2")))
        )
    ),
    
    TestCase("can parse repeated function calls", fun() =>
        assertSuccessfulParse(
            "go()()()",
            nodes.call(nodes.call(nodes.call(nodes.ref("go"), emptyList), emptyList), emptyList)
        )
    ),
    
    TestCase("can parse member access", fun() =>
        assertSuccessfulParse(
            "bob.name",
            nodes.memberAccess(nodes.ref("bob"), "name")
        )
    ),
    
    TestCase("can parse function with no arguments", fun() =>
        assertSuccessfulParse(
            "fun() => ()",
            nodes.function(
                emptyList,
                nodes.unit()
            )
        )
    ),
    
    TestCase("can parse function with formal arguments", fun() =>
        assertSuccessfulParse(
            "fun(first: String, second: Any) => ()",
            nodes.function(
                listOf(
                    nodes.formalArgument("first", nodes.ref("String")),
                    nodes.formalArgument("second", nodes.ref("Any"))
                ),
                nodes.unit()
            )
        )
    )
);
    
def stringSource fun(string: String) =>
    createStringSource(string, "raw string");
    
def parse fun(input: StringSource) =>
    Parser().parse(expressions.expression, input);

def assertSuccessfulParse fun(input: String, expected: Node) => do {
    val source = stringSource(input);
    val result = Parser().parseWithoutEndToken(expressions.expressionRule, source);
    return assertThat[Node](result, isSuccess[Node](equalTo[Node](expected)));
}
