module shed.compiler.parsing.expressionsTest;

members {
    testCases
}

import hat.TestCase;
import lop.rules;

import shed.compiler.nodes;
import shed.compiler.nodes.Node;
import shed.compiler.parsing.expressions.expressionRules;
import shed.compiler.parsing.testing.createAssertSuccessfulParse;

val testCases = listOf[TestCase](
    TestCase("can parse variable reference", fun() =>
        assertSuccessfulParse("blah", nodes.variableReference("blah"))
    ),
    
    TestCase("can parse if-then-else expression", fun() =>
        assertSuccessfulParse(
            "if true then 1 else 0",
            nodes.ifThenElse(
                nodes.boolean(true),
                nodes.number("1"),
                nodes.number("0")
            )
        )
    ),
    
    TestCase("can parse nested if-then-else expressions", fun() =>
        assertSuccessfulParse(
            "if true then 1 else if false then 0 else 2",
            nodes.ifThenElse(
                nodes.boolean(true),
                nodes.number("1"),
                nodes.ifThenElse(
                    nodes.boolean(false),
                    nodes.number("0"),
                    nodes.number("2")
                )
            )
        )
    ),
    
    TestCase("can parse bracketed expression", fun() =>
        assertSuccessfulParse("(false)", nodes.boolean(false))
    ),
    
    TestCase("can parse function call with no arguments", fun() =>
        assertSuccessfulParse("go()", nodes.call(nodes.ref("go"), emptyList))
    ),
    
    TestCase("can parse function call with one argument", fun() =>
        assertSuccessfulParse(
            "print(\"Hello\")",
            nodes.call(nodes.ref("print"), listOf(nodes.string("Hello")))
        )
    ),
    
    TestCase("can parse function call with multiple arguments", fun() =>
        assertSuccessfulParse(
            "equal(1,2)",
            nodes.call(nodes.ref("equal"), listOf(nodes.number("1"), nodes.number("2")))
        )
    ),
    
    TestCase("can parse repeated function calls", fun() =>
        assertSuccessfulParse(
            "go()()()",
            nodes.call(nodes.call(nodes.call(nodes.ref("go"), emptyList), emptyList), emptyList)
        )
    ),
    
    TestCase("can parse member access", fun() =>
        assertSuccessfulParse(
            "bob.name",
            nodes.memberAccess(nodes.ref("bob"), "name")
        )
    ),
    
    TestCase("can parse function with no arguments", fun() =>
        assertSuccessfulParse(
            "fun() => ()",
            nodes.function(
                emptyList,
                nodes.unit()
            )
        )
    ),
    
    TestCase("can parse function with formal arguments", fun() =>
        assertSuccessfulParse(
            "fun(first: String, second: Any) => ()",
            nodes.function(
                listOf(
                    nodes.formalArgument("first", nodes.ref("String")),
                    nodes.formalArgument("second", nodes.ref("Any"))
                ),
                nodes.unit()
            )
        )
    ),
    
    TestCase("can parse empty object", fun() =>
        assertSuccessfulParse(
            "object { }",
            nodes.obj(
                emptyList,
                emptyList
            )
        )
    ),
    
    TestCase("can parse object with body", fun() =>
        assertSuccessfulParse(
            "object { x y }",
            nodes.obj(
                emptyList,
                listOf(stubStatement("x"), stubStatement("y"))
            )
        )
    ),
    
    TestCase("can parse object with empty members", fun() =>
        assertSuccessfulParse(
            "object { members { } x y }",
            nodes.obj(
                emptyList,
                listOf(stubStatement("x"), stubStatement("y"))
            )
        )
    ),
    
    TestCase("members can be empty", fun() =>
        assertSuccessfulParse(
            "members { }",
            emptyList
        )
    )
);
    
def stubStatement fun(name: String) =>
    nodes.expressionStatement(nodes.ref(name))

val statementRule =
    rules.map(
        rules.tokenOfType("identifier"),
        stubStatement
    );

val assertSuccessfulParse = createAssertSuccessfulParse(expressionRules(statementRule).expression());

// TODO: members should be in their own module?
val assertSuccessfulMembersParse =
    createAssertSuccessfulParse(expressionRules(statementRule).membersRule());
