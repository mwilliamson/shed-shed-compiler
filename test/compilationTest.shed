module shed/compiler/compilationTest;

members::
    testCases

import nodejs;

import hat.TestCase;
import duck.assertThat;
import duck.MatchResult;

import shed/compiler/compilation;

def assertIsTokenisedTo fun(input: StringSource, expectedTokens: List[Token]) => do::
    val tokeniser = Tokeniser();
    val actualTokens = tokeniser.tokenise(input);
    val expectedMatchers = expectedTokens.map(equalTo[Token]);
    return assertThat[List[Token]](actualTokens, isList[Token](expectedMatchers));

val testCases = listOf(
    TestCase("can execute program containing print statement", fun() => do::
        val shedProgram = "print(\"Hello world\");";
        val jsProgramPromise = compilation.compileString(shedProgram);
        
        return jsProgramPromise.bind(fun(jsProgram: String) =>
            nodejs.executeString(jsProgram).map(fun(result: ExecutionResult) =>
                assertThat(result, isSuccessWithOutput("Hello world"))
            )
        );
    )
);

val testCases = listOf(
    TestCase("can import module", fun() => do::
        val shedProgram = "import options;\nprint(options.none.orElse(fun() => \"Hello world\"));";
        val jsProgramPromise = compilation.compileString(shedProgram);
        
        return jsProgramPromise.bind(fun(jsProgram: String) =>
            nodejs.executeString(jsProgram).map(fun(result: ExecutionResult) =>
                assertThat(result, isSuccessWithOutput("Hello world"))
            )
        );
    )
);

val testCases = listOf(
    TestCase("can import value from module", fun() => do::
        val shedProgram = "import options.none;\nprint(none.orElse(fun() => \"Hello world\"));";
        val jsProgramPromise = compilation.compileString(shedProgram);
        
        return jsProgramPromise.bind(fun(jsProgram: String) =>
            nodejs.executeString(jsProgram).map(fun(result: ExecutionResult) =>
                assertThat(result, isSuccessWithOutput("Hello world"))
            )
        );
    )
);
    
def isSuccessWithOutput fun(expectedOutput: String) => object::
    members::
        describeSelf,
        matches,
        describeMismatch,
        matchesWithDescription
    
    def describeSelf fun() => "successful exit with output: ".concat(expectedOutput);
    def matches fun(result: ParseResult) =>
        matchesWithDescription(result).matches();
    
    def describeMismatch fun(result: ParseResult) =>
        matchesWithDescription(result).mismatchDescription();
        
    def matchesWithDescription fun(result: ExecutionResult) =>
        if not(result.isSuccess()) then
            MatchResult(
                false,
                "exit code was ".concat(result.exitCode().toString())
                    .concat(describeOutput(result))
                    .concat(describeError(result))
            )
        else if not(equal(result.stdout(), expectedOutput)) then
            MatchResult(false, describeOutput(result))
        else
            MatchResult(true, "");
            
    def describeOutput fun(result: ExecutionResult) =>
        "stdout was: ".concat(result.stdout())
        
    def describeError fun(result: ExecutionResult) =>
        "stderr was: ".concat(result.stderr())
