module shed.compiler.codeGeneration.microJavaScriptTest;

members {
    testCases
}

import hat.TestCase;
import duck.assertThat;
import duck.equalTo;

import shed.compiler.codeGeneration.microJavaScript.Generator;
import shed.compiler.nodes;
import shed.compiler.javaScript.js;

val shed = nodes;

val testCases = listOf(
    TestCase("Shed unit generates reference to $shed.unit", fun() =>
        assertThat(
            generate(shed.unit()),
            equalTo(js.propertyAccess(js.ref("$shed"), "unit"))
        )
    ),
    
    TestCase("Shed boolean generates JavaScript boolean", fun() =>
        assertThat(
            generate(shed.boolean(true)),
            equalTo(js.boolean(true))
        )
    ),
    
    TestCase("Shed number generates boxed JavaScript number", fun() =>
        assertThat(
            generate(shed.number("4.2")),
            equalTo(js.call(js.propertyAccess(js.ref("$shed"), "number"), listOf(js.number("4.2"))))
        )
    ),
    
    TestCase("Shed string generates boxed JavaScript string", fun() =>
        assertThat(
            generate(shed.string("blah")),
            equalTo(js.call(js.propertyAccess(js.ref("$shed"), "string"), listOf(js.string("blah"))))
        )
    ),
    
    TestCase("Shed variable reference generates JavaScript variable reference", fun() =>
        assertThat(
            generate(shed.ref("blah")),
            equalTo(js.ref("blah"))
        )
    ),
    
    TestCase("Shed if-then-else expression generates JavaScript conditional operator", fun() => do {
        val condition = shed.ref("condition");
        val trueValue = shed.ref("trueValue");
        val falseValue = shed.ref("falseValue");
        return assertThat(
            generate(shed.ifThenElse(condition, trueValue, falseValue)),
            equalTo(js.conditional(stub(condition), stub(trueValue), stub(falseValue)))
        );
    }),
    
    TestCase("Shed call generates JavaScript call", fun() =>
        assertThat(
            generate(shed.call(shed.ref("print"), listOf(shed.string("Hello")))),
            equalTo(js.call(stub(shed.ref("print")), listOf(stub(shed.string("Hello")))))
        )
    ),
    
    TestCase("Shed member access generates JavaScript property access", fun() =>
        assertThat(
            generate(shed.memberAccess(shed.ref("bob"), "name")),
            equalTo(js.propertyAccess(stub(shed.ref("bob")), "name"))
        )
    ),
    
    TestCase("Shed function generates JavaScript function wrapped in $shed.function", fun() =>
        assertThat(
            generate(shed.function(
                listOf(shed.formalArgument("name", shed.ref("String"))),
                shed.unit()
            )),
            equalTo(js.call(
                js.propertyAccess(js.ref("$shed"), "function"),
                listOf(js.function(
                    listOf("name"),
                    listOf(js.ret(stub(shed.unit())))
                ))
            ))
        )
    ),
    
    TestCase("Shed expression statement generates JavaScript expression statement", fun() =>
        assertThat(
            generate(shed.expressionStatement(shed.string("Hello"))),
            equalTo(js.expressionStatement(stub(shed.string("Hello"))))
        )
    ),
    
    TestCase("Shed return statement generates JavaScript return statement", fun() =>
        assertThat(
            generate(shed.ret(shed.string("Hello"))),
            equalTo(js.ret(stub(shed.string("Hello"))))
        )
    ),
    
    TestCase("Shed module generates list of JavaScript statements", fun() => do {
        val shedStatement = shed.expressionStatement(shed.string("Hello"));
        return assertThat(
            generate(shed.moduleNode(listOf(shedStatement))),
            equalTo(js.statements(listOf(stub(shedStatement))))
        );
    })
);

def subGenerate fun(node: ShedNode) =>
    stub(node)
    
def stub fun(node: ShedNode) =>
    js.ref("$".concat(represent(node)))

val generator = Generator(subGenerate);
val generate = generator.generate;
