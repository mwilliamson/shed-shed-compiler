module shed/compiler/referenceResolvingTest;

members::
    testCases

import options.none;
import options.some;

import hat.TestCase;
import duck.assertThat;
import duck.equalTo;
import duck.anything;

import shed/compiler/nodes;
import shed/compiler/referenceResolving.resolveReferences;
import shed/compiler/referenceResolving.emptyContext;
import shed/compiler/referenceResolving.variableNotInScope;
import shed/compiler/resultMatchers.isSuccess;
import shed/compiler/results.failure;

def requiresNoContext fun(node: ShedNode) => fun() =>
    assertThat(resolveReferences(node, emptyContext), isSuccess(anything))

def badRefDetected fun(node: ShedNode) => fun() =>
    assertThat(
        resolveReferences(node, emptyContext),
        equalTo(failure(listOf(variableNotInScope("badRef"))))
    )
    
val badRef = nodes.ref("badRef");
val noRef = nodes.unit();

val dummyNode = object::
    pass

val testCases = listOf(
    TestCase("unit literal requires no context", requiresNoContext(nodes.unit())),
    TestCase("number literal requires no context", requiresNoContext(nodes.number("2"))),
    TestCase("string literal requires no context", requiresNoContext(nodes.string("hello"))),
    TestCase("boolean literal requires no context", requiresNoContext(nodes.bool(true))),
    
    TestCase("variable reference fails if context is empty",
        badRefDetected(badRef)),
    
    TestCase("variable reference fails if context doesn't contain name", fun() => let
        val context = emptyContext.add("song", dummyNode)
        in assertThat(
            resolveReferences(nodes.ref("artist"), context),
            equalTo(failure(listOf(variableNotInScope("artist"))))
        )
    ),
    
    TestCase("variable reference succeeds if name is in scope", fun() => let
        val context = emptyContext.add("song", dummyNode)
        in assertThat(
            resolveReferences(nodes.ref("song"), context),
            isSuccess(anything)
        )
    ),
    
    TestCase("function fails if body fails",
        badRefDetected(nodes.func(emptyList, badRef))),
    
    TestCase("function node adds variable to scope", fun() => let
        val context = emptyContext.add("String", dummyNode)
        val func = nodes.func(
            listOf(nodes.formalArgument("song", none)),
            nodes.ref("song")
        )
        in assertThat(
            resolveReferences(func, context),
            isSuccess(anything)
        )
    ),
    
    TestCase("function creates new scope for formal args and body", fun() => let
        val func = nodes.func(
            listOf(nodes.formalArgument("song", none)),
            noRef
        )
        val call = nodes.call(noRef, listOf(func, nodes.ref("song")))
        in assertThat(
            resolveReferences(call, emptyContext),
            equalTo(failure(listOf(variableNotInScope("song"))))
        )
    ),
    
    TestCase("formal arguments of function have references resolved", 
        badRefDetected(nodes.func(
            listOf(nodes.formalArgument("song", some(badRef))),
            noRef
        ))
    ),
    
    TestCase("type of formal argument has references resolved", 
        badRefDetected(nodes.formalArgument("song", some(badRef)))),
    
    TestCase("condition of if has references resolved", 
        badRefDetected(nodes.ifThenElse(badRef, noRef, noRef))),
    
    TestCase("true branch of if has references resolved",
        badRefDetected(nodes.ifThenElse(noRef, badRef, noRef))),
    
    TestCase("false branch of if has references resolved", 
        badRefDetected(nodes.ifThenElse(noRef, noRef, badRef))),
        
    TestCase("function of call expression has references resolved", 
        badRefDetected(nodes.call(badRef, emptyList))),
        
    TestCase("arguments of call expression has references resolved", 
        badRefDetected(nodes.call(noRef, listOf(badRef)))),
        
    TestCase("function of type application has references resolved", 
        badRefDetected(nodes.typeApplication(badRef, emptyList))),
        
    TestCase("arguments of type application has references resolved", 
        badRefDetected(nodes.typeApplication(noRef, listOf(badRef)))),
        
    TestCase("left part of member access has references resolved", 
        badRefDetected(nodes.memberAccess(badRef, "name"))),
    
    TestCase("member declarations of object have references resolved", 
        badRefDetected(nodes.obj(listOf(nodes.memberDeclaration("bad", badRef)), emptyList))),
    
    TestCase("statements of object have references resolved", 
        badRefDetected(nodes.obj(emptyList, listOf(badRef))))
)
