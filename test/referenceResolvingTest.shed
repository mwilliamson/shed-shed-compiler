module shed.compiler.referenceResolvingTest;

members {
    testCases
}

import hat.TestCase;
import duck.assertThat;
import duck.equalTo;
import duck.anything;

import shed.compiler.nodes;
import shed.compiler.referenceResolving.resolveReferences;
import shed.compiler.referenceResolving.emptyContext;
import shed.compiler.resultMatchers.isSuccess;
import shed.compiler.results.failure;

def requiresNoContext fun(node: ShedNode) => fun() =>
    assertThat(resolveReferences(node, emptyContext), isSuccess(anything))

val dummyNode = object { };

val testCases = listOf(
    TestCase("unit literal requires no context", requiresNoContext(nodes.unit())),
    TestCase("number literal requires no context", requiresNoContext(nodes.number("2"))),
    TestCase("string literal requires no context", requiresNoContext(nodes.string("hello"))),
    TestCase("boolean literal requires no context", requiresNoContext(nodes.bool(true))),
    
    TestCase("variable reference fails if context is empty", fun() =>
        assertThat(
            resolveReferences(nodes.ref("song"), emptyContext),
            equalTo(failure(listOf("variable not in scope: song")))
        )
    ),
    
    TestCase("variable reference fails if context doesn't contain name", fun() => let
        val context = emptyContext.add("song", dummyNode)
        in assertThat(
            resolveReferences(nodes.ref("artist"), context),
            equalTo(failure(listOf("variable not in scope: artist")))
        )
    ),
    
    TestCase("variable reference succeeds if name is in scope", fun() => let
        val context = emptyContext.add("song", dummyNode)
        in assertThat(
            resolveReferences(nodes.ref("song"), context),
            isSuccess(anything)
        )
    )
);
