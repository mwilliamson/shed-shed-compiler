module shed/compiler/referenceResolvingTest;

members::
    testCases

import options.none;
import options.some;

import hat.TestCase;
import duck.assertThat;
import duck.equalTo;
import duck.anything;

import shed/compiler/nodes;
import shed/compiler/referenceResolving.resolveReferences;
import shed/compiler/referenceResolving.emptyContext;
import shed/compiler/referenceResolving.variableNotInScope;
import shed/compiler/resultMatchers.isSuccess;
import shed/compiler/results.failure;

def badRefDetected fun(node: ShedNode) => fun() =>
    assertThat(
        resolveReferences(node, emptyContext),
        equalTo(failure(listOf(variableNotInScope("badRef"))))
    )

def successfulReferenceResolution fun(node: ShedNode) => fun() =>
    assertThat(resolveReferences(node, emptyContext), isSuccess(anything))

val requiresNoContext = successfulReferenceResolution
    
val badRef = nodes.ref("badRef");
val noRef = nodes.unit();

val dummyNode = object::
    pass

val testCases = listOf(
    TestCase("unit literal requires no context", requiresNoContext(nodes.unit())),
    TestCase("number literal requires no context", requiresNoContext(nodes.number("2"))),
    TestCase("string literal requires no context", requiresNoContext(nodes.string("hello"))),
    TestCase("boolean literal requires no context", requiresNoContext(nodes.bool(true))),
    
    TestCase("variable reference fails if context is empty",
        badRefDetected(badRef)),
    
    TestCase("variable reference fails if context doesn't contain name", fun() => let
        val context = emptyContext.add("song", dummyNode)
        in assertThat(
            resolveReferences(nodes.ref("artist"), context),
            equalTo(failure(listOf(variableNotInScope("artist"))))
        )
    ),
    
    TestCase("variable reference succeeds if name is in scope", fun() => let
        val context = emptyContext.add("song", dummyNode)
        in assertThat(
            resolveReferences(nodes.ref("song"), context),
            isSuccess(anything)
        )
    ),
    
    TestCase("function fails if body fails",
        badRefDetected(nodes.func(emptyList, badRef))),
    
    TestCase("function node adds variable to scope",
        successfulReferenceResolution(nodes.func(
            listOf(nodes.formalArgument("song", none)),
            nodes.ref("song")
        ))),
    
    TestCase("function creates new scope for formal args and body", fun() => let
        val func = nodes.func(
            listOf(nodes.formalArgument("song", none)),
            noRef
        )
        val call = nodes.call(noRef, listOf(func, nodes.ref("song")))
        in assertThat(
            resolveReferences(call, emptyContext),
            equalTo(failure(listOf(variableNotInScope("song"))))
        )
    ),
    
    TestCase("formal arguments of function have references resolved",
        badRefDetected(nodes.func(
            listOf(nodes.formalArgument("song", some(badRef))),
            noRef
        ))
    ),
    
    TestCase("type of formal argument has references resolved",
        badRefDetected(nodes.formalArgument("song", some(badRef)))),
    
    TestCase("condition of if has references resolved",
        badRefDetected(nodes.ifThenElse(badRef, noRef, noRef))),
    
    TestCase("true branch of if has references resolved",
        badRefDetected(nodes.ifThenElse(noRef, badRef, noRef))),
    
    TestCase("false branch of if has references resolved",
        badRefDetected(nodes.ifThenElse(noRef, noRef, badRef))),
        
    TestCase("function of call expression has references resolved",
        badRefDetected(nodes.call(badRef, emptyList))),
        
    TestCase("arguments of call expression has references resolved", 
        badRefDetected(nodes.call(noRef, listOf(badRef)))),
        
    TestCase("function of type application has references resolved",
        badRefDetected(nodes.typeApplication(badRef, emptyList))),
        
    TestCase("arguments of type application has references resolved",
        badRefDetected(nodes.typeApplication(noRef, listOf(badRef)))),
        
    TestCase("left part of member access has references resolved",
        badRefDetected(nodes.memberAccess(badRef, "name"))),
    
    TestCase("member declarations of object have references resolved",
        badRefDetected(nodes.obj(listOf(nodes.memberDeclaration("bad", badRef)), emptyList))),
    
    TestCase("statements of object have references resolved", 
        badRefDetected(nodes.obj(emptyList, listOf(badRef)))),
    
    TestCase("members are added to object scope before resolving statements",
        successfulReferenceResolution(nodes.obj(
            listOf(nodes.memberDeclaration("song", nodes.ref("song"))),
            listOf(nodes.valDeclaration("song", noRef))
        ))),
    
    TestCase("body of class has references resolved",
        badRefDetected(nodes.classDeclaration(
            emptyList,
            nodes.obj(emptyList, listOf(badRef))
        ))),
    
    TestCase("class node adds variable to scope",
        successfulReferenceResolution(nodes.classDeclaration(
            listOf(nodes.formalArgument("song", none)),
            nodes.obj(emptyList, listOf(nodes.ref("song")))
        ))),
    
    TestCase("value of val declaration has references resolved",
        badRefDetected(nodes.valDeclaration("song", badRef))),
    
    TestCase("val declaration adds name to context", fun() => let
        val result = resolveReferences(nodes.valDeclaration("song", noRef), emptyContext)
        val context = result.value()
        in assertThat(context.contains("song"), equalTo(true))
    ),
    
    TestCase("statements of do block have references resolved",
        badRefDetected(nodes.doBlock(listOf(badRef)))),
    
    TestCase("expression of let-in expression has references resolved",
        badRefDetected(nodes.letIn(emptyList, badRef))),
    
    TestCase("val declarations of let-in expression have references resolved",
        badRefDetected(nodes.letIn(listOf(nodes.valDeclaration("x", badRef)), noRef))),
    
    TestCase("left of and expression has references resolved",
        badRefDetected(nodes.and(badRef, noRef))),
    
    TestCase("right of and expression has references resolved",
        badRefDetected(nodes.and(noRef, badRef))),
    
    TestCase("expression of expression statement has references resolved",
        badRefDetected(nodes.expressionStatement(badRef))),
    
    TestCase("value of return statement has references resolved",
        badRefDetected(nodes.ret(badRef))),
    
    TestCase("value definition has references resolved",
        badRefDetected(nodes.definition("song", badRef))),
    
    TestCase("definition adds name to context", fun() => let
        val result = resolveReferences(nodes.definition("song", noRef), emptyContext)
        val context = result.value()
        in assertThat(context.contains("song"), equalTo(true))),
    
    TestCase("import statement adds name of module to context", fun() => let
        val result = resolveReferences(nodes.importStatement(listOf("song"), emptyList), emptyContext)
        val context = result.value()
        in assertThat(context.contains("song"), equalTo(true))),
    
    TestCase("import statement adds name of module to context", fun() => let
        val result = resolveReferences(nodes.importStatement(listOf("song"), emptyList), emptyContext)
        val context = result.value()
        in assertThat(context.contains("song"), equalTo(true)))
)
