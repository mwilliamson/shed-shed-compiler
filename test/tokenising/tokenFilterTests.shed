module shed/compiler/tokenising/tokenFilterTests;

members {
    testCases
}

import hat.TestCase;
import hat;
import duck.assertThat;
import duck.isList;
import duck.equalTo;

import shed/compiler/tokenising/tokens;
import shed/compiler/tokenising/tokenFilter.filterTokens;
import lop/strings;
    

def assertFilteredTokens fun(inputTokens: List[Token], matcher: Matcher[List[Token]]) =>
    filterTokens(inputTokens)
        .map(fun(filteredTokens: List[Token]) =>
            assertThat(filteredTokens, matcher)
        )
        .valueOrElse(fun() =>
            hat.results.failure("Failed to filter tokens")
        )

val testCases = listOf[TestCase](
    TestCase("whitespace tokens are filtered out", fun() => do {
        return assertFilteredTokens(
            listOf(
                identifier("x"),
                whitespace(" \t"),
                identifier("y")
            ),
            equalTo(listOf(
                identifier("x"),
                identifier("y")
            ))
        );
    }),
    
    TestCase("newline before comment is not significant", fun() => do {
        return assertFilteredTokens(
            listOf(
                whitespace("\n"),
                comment("// asf"),
                whitespace("\n  ")
            ),
            equalTo(emptyList)
        );
    }),

    TestCase("comment tokens are filtered out", fun() => do {
        return assertFilteredTokens(
            listOf(
                comment("// saf")
            ),
            equalTo(emptyList)
        );
    }),
    
    TestCase("new lines are significant at zero indentation", fun() => do {
        return assertFilteredTokens(
            listOf(
                whitespace("\n")
            ),
            equalTo(listOf(
                newline()
            ))
        );
    }),
    
    TestCase("blank lines are ignored", fun() => do {
        return assertFilteredTokens(
            listOf(
                whitespace("\n   \n")
            ),
            equalTo(listOf(
                newline()
            ))
        );
    }),
    
    TestCase("new line followed by whitespace is ignored", fun() => do {
        return assertFilteredTokens(
            listOf(
                whitespace("\n    ")
            ),
            equalTo(emptyList)
        );
    }),
    
    TestCase("no newline if opening brace is last token", fun() => do {
        return assertFilteredTokens(
            listOf(
                symbol("{")
            ),
            equalTo(listOf(
                symbol("{")
            ))
        );
    }),
    
    TestCase("whitespace after opening brace is not significant", fun() => do {
        return assertFilteredTokens(
            listOf(
                symbol("{"),
                whitespace(" ")
            ),
            equalTo(listOf(
                symbol("{")
            ))
        );
    }),
    
    TestCase("indented newline after opening brace is significant", fun() => do {
        return assertFilteredTokens(
            listOf(
                symbol("{"),
                whitespace("\n    ")
            ),
            equalTo(listOf(
                symbol("{"),
                newline()
            ))
        );
    }),
    
    TestCase("indented newline after opening brace is ignored if there is a intervening token", fun() => do {
        return assertFilteredTokens(
            listOf(
                symbol("{"),
                symbol("+"),
                whitespace("\n    ")
            ),
            equalTo(listOf(
                symbol("{"),
                symbol("+")
            ))
        );
    }),
    
    TestCase("indented newlines at same indentation after opening brace are significant", fun() => do {
        return assertFilteredTokens(
            listOf(
                symbol("{"),
                whitespace("\n    "),
                symbol("+"),
                whitespace("\n    ")
            ),
            equalTo(listOf(
                symbol("{"),
                newline(),
                symbol("+"),
                newline()
            ))
        );
    }),
    
    TestCase("closing brace pops indentation stack", fun() => do {
        return assertFilteredTokens(
            listOf(
                symbol("{"),
                whitespace("\n    "),
                symbol("}"),
                whitespace("\n    ")
            ),
            equalTo(listOf(
                symbol("{"),
                newline(),
                symbol("}")
            ))
        );
    }),
    
    TestCase("unmatched closing brace does not cause error", fun() => do {
        return assertFilteredTokens(
            listOf(
                symbol("}")
            ),
            equalTo(listOf(
                symbol("}")
            ))
        );
    }),
    
    TestCase("newline before closing brace is significant", fun() => do {
        return assertFilteredTokens(
            listOf(
                symbol("{"),
                whitespace("\n    "),
                symbol("+"),
                whitespace("\n"),
                symbol("}"),
                whitespace("\n    ")
            ),
            equalTo(listOf(
                symbol("{"),
                newline(),
                symbol("+"),
                newline(),
                symbol("}")
            ))
        );
    }),
    
    TestCase("whitespace without newline before closing brace is not significant", fun() => do {
        return assertFilteredTokens(
            listOf(
                symbol("{"),
                whitespace("\n    "),
                symbol("+"),
                whitespace("  "),
                symbol("}"),
                whitespace("\n    ")
            ),
            equalTo(listOf(
                symbol("{"),
                newline(),
                symbol("+"),
                symbol("}")
            ))
        );
    }),
    
    TestCase("opening brace then closing brace without newline preserves indentation significance", fun() => do {
        return assertFilteredTokens(
            listOf(
                symbol("{"),
                whitespace("\n    "),
                symbol("{"),
                symbol("}"),
                whitespace("\n    ")
            ),
            equalTo(listOf(
                symbol("{"),
                newline(),
                symbol("{"),
                symbol("}"),
                newline()
            ))
        );
    })
);

def identifier fun(value: String) =>
    tokens.identifier(value, stringSource())

def whitespace fun(value: String) =>
    tokens.whitespace(value, stringSource())

def symbol fun(value: String) =>
    tokens.symbol(value, stringSource())

def comment fun(value: String) =>
    tokens.comment(value, stringSource())
    
def newline fun() =>
    tokens.newline(stringSource())

    
def stringSource fun() =>
    strings.createStringSource("", "raw string");
